### Dynamic Programming
#### 定义
- 大规模问题依赖小规模关系
    - Note: DP是一种思想并不是一种算法，偏哲学 - 类似二叉树分治法

#### 特点
###### 与二叉树 分治法
- 二叉树分治法为什么不是DP
    - 二叉树分治法遍历没有重复子问题
    - 数字三角形有重复子问题 - 就可以使用DP
- 如果没有重复子问题无法使用DP, DP就是为了优化重复子问题

###### 与贪心算法
- 贪心算法最求眼前利益最大化，每一步都贪心认为是最优解
- DP最求长远利益最大化

#### 实现方式
- 记忆化搜索 - 递归
- 循环遍历 - 递推
    - button up - 初始化底层 - 我要prev计算结果push给当前的计算结果
    - top down - 初始化顶层 - 当前结果等于分治小问题的结果
        - 等价于用递推实现了记忆化搜索的分治法
    
#### 动态规划四要素
- 动规的状态 State - 递归的定义
    - 坐标，前缀，区间
    - f[i] 或者 f[i][j] 代表某些特定条件下某个规模更小问题的答案
        - 举例: 数字三角形 f[i][j]-> 从i层第j个点到底层的最短路径
            - f[row][0-col] -> 最底层每个点到底层最短路径等于本身
    - 规模更小用参数i,j之类的来规划
- 动规的方程 Function - 递归的拆解
    - 上一步从哪里来，如何依赖更小的问题
    - 大问题拆解小问题
    - f[i][j] = 通过规模更小的一些状态求 max/min/sum/or 等
        - sum通常求路径和
        - or通常求方案可不可行 (存不存在可行解)
- 动规的初始化 Initialize - 递归的出口
    - 用来给状态赋初始值
    - 设定无法再拆解的极限小的状态下的值
- 动规的答案 Answer - 递归的调用
    - 最后的答案
        - f[n][m]
        - Math.max(f[n][0],...,f[n][m])
        
#### 动态规划的使用场景
- 求最值 Max/Min -> dp[][] = Max/Min(dp[][], dp[][],...)
- 求可行性 - 是否存在一种方案 -> dp[][] = dp[][] or dp[][] or ...
- 求方案总数 - 只求总数不求具体方案 -> dp[][] = sum(dp[][], dp[][], ...)
    - !!!求具体方案 DFS更加擅长
    - 求方案总数DP会比较快
    
##### 动态规划不适用的场景
- 求具体方案
    - 求一个具体方案可以
    - 求所有具体方案不行
- 暴力搜索时间复杂度已经是多项式 
    - DP可以将指数化的暴搜优化到多项式级别
- 没有重复性子问题
- 输入数据是无序 - 不是拓扑排序关系
    - 存在环形结构的话无法用DP

#### 动态规划的题型
- Note: 动态规划状态最为重要，找对题型找到该题型对应的状态。
    - 动态规划本身就是一个天然拓扑序，所以如果存在循环依赖(环结构)问题不能使用DP
    - DP**只能解决拓扑依赖问题** 
        - Knight Shortest paths I 和 II：I只能用BFS,因为I中有8个方向，存在环型依赖(左上，右下一直循环)
- 坐标型
    - 一维坐标 dp[i] 从起点到坐标 i的最优解/方案数/可行性
    - 二维坐标 dp[i][j]
- 前缀型
    - 一个字符串划分 - 划分型
        - 状态：
            - dp[i] 表示前 i个字符的最优值/方案数/可行性
            - dp[i][j] 表示前i个字符划分成j个部分的最值/方案数/可行性
                - word break
    - 两个字符串匹配 - 匹配型
        - 状态: 
            - dp[i][j]表示第一个字符串前i个匹配第二个字符串前j个
                - longest common sequence, wildcard matching  
- 背包型
    - 最常考
    - 0/1背包，完全背包，多重背包
    - 状态
        - dp[i][j]表示前i个物品里选出一些物品，物品总和为j的最优解/方案总数/可行性
        - 优化：dp[i][j] 可以降维成 1维 dp[i]
    
- 区间型
    - 考较少
    - 状态：
      - dp[i][j] 表示区间i,j之间的最值/方案数/可行性
        - Stone Game
- 博弈型
    - 考的少
- 树型
    - 基本不考
- 状态压缩型
    - TSP问题 - 加分项
    - 其他基本不考
    
##### 动态规划的优化方法
- 滚动数组
    - Triangle
##### 如何确定你的DP是正确的
- 状态要找对，确定要用什么状态进行计算
- DP每一步计算是依赖你前一步的计算结果 - 推倒顺序一定要明确，不是随便遍历
    - 必须保证前一步计算结果是已知，并且完全计算
        - 骑士最短路：必须要先遍历每一列再遍历每一行 - 因为先遍历每一行一部分前一步的结果会成为未知
        - LIS II：必须将2D 矩阵进行压缩并且由小到大排序，否则如果按照原始矩阵逐行计算会出现一些前一步结果未知的情况
##### 背包问题
- 0/1背包
- 多重背包
    - 每一个物品可以选或者选多次
    - for loop中加一层count层这样时间复杂度O(n*m^2)会超时



##### 背包DP问题
- 0/1背包
    - 该物品要么选1,要么不选0
    - 状态 - 两种状态都可
        - 1. f[i][j] 前i个物品选出重量和为<=j的可行性 - boolean
        - 2. f[i][j] 前i个物品选出重量和<=j的最大和为多少 - int



