### 分治法

#### Divide and Conquer
- 将大问题化解成同类型小问题，除了问题规模不同 - 参数值不同但是参数属性是相同的，处理逻辑步骤完全一致
    - 分治法需要返回子问题结果上级需要进行汇总
- 适用于解决二叉树问题
- Note: 分治和减治二分的区别
    - 减治二分是将一个大问题通过条件将大问题规模缩小到一个很小的范围进行求解：将大问题 - debuff成一个小问题
    - 分治是通过将一个大问题分解成很多个小问题，解决每一个小问题最后汇总出大问题的答案：大问题 -> 小问题 -> 汇总求解大问题(递归)
    
#### 什么数据结构适合进行分治求解
- 二叉树 - 整个树左右子树都是二叉树 99%二叉树问题都可以用分治(递归)求解


#### 二叉树分治法
- 二叉树分治法属于后序遍历 - 左右根
- 二叉树分治模板
    - 根本是一种特殊遍历，且是后序遍历 左右根
```

public <T> divideConquer(TreeNode root) {
    if(root==null) {
        处理空树应该返回的结果
    }

    //if(root.left==null && root.right==null) {}
    
    右子树返回结果 = divideConquer(root.left);
    左子树返回结果 = divideConquer(root.right);
    整棵树结果 = 按照一定方法合并左右子树结果
    
    return 整棵树结果
}

```
##### 二叉树考点剖析 - 考点本质 DFS
- 二叉树求值，求路径
    - Max/Min/Average/Sum/Paths
    - Find LCA
        - 分治法
        - 巧妙算法 - 求每一个点深度，两个目标点之间depth最小的node
- 二叉树结构变化
    - Flattern BT to LinkedList
- 二叉搜索树 BST


#### 分治法时可能需要返回多个参数
- 如何在Java中返回类似python多类型参数
    - 建立一个Object

#### 分治法和动态规划
- 两者有相通也有不同
    - 前提两个定义：
        - 最优子结构：如果问题的一个最优解中包含子问题的最优解，则该问题具有最优子结构
        - 重叠子问题：如果两个子问题，他们确实是相同的子问题，只是作为不同问题的子问题出现的话，则他们是重叠的
            - 如果子问题相互独立，能且只能使用分治，如果存在重叠子问题，动态规划是更好的算法
    - 分治法：解决相对独立子问题
        - 经典例子：Merge Sort,求连续最大和，汉诺塔问题，
    - 动态规划：解决有重叠子问题
        - 经典例子: 