### DFS - Depth First Search

#### DFS能解决的问题
- 连通性问题 (BFS 和 DFS都可以做)
    - Flood Fill
    - 图和树遍历
        - 只要目的地之间是联通的那么DFS一定能搜到
        
#### 二叉树 DFS问题
- 时间复杂度
    - Time: O(N) 遍历每一个节点
    - Space: O(h) 递归遍历 - 保存树高层节点
- 常见问题
    - 遍历类问题(路径和)


#### 非二叉树 DFS问题 (隐式图搜索问题)
- 排列问题
- 组合问题
- 时间复杂度
    - O(方案总数*构造每一个方案的时间)
        - 排列: O(N!*N)
        - 组合: O(2^N*N)
- 解题思路
    - 要明确什么是点什么是边

#### 补充:
- 隐式图
    - 仅给出初始节点，目标节点以及生成节点的约束条件，需要按照拓展规则自行扩展节点
- 非启发式搜索(盲目搜索)
    - 就是暴力搜索，遍历每一个节点
    - BFS/DFS就是盲目搜索
- 启发式搜索(有信息搜索)
    - 利用问题存在的启发信息进行搜索，实现减枝降低复杂度
    - 记忆化搜索
- 在做DFS之前
    - 先明确以怎么个顺序遍历图
    - 常见方向
        - 2D图
            - 逐行遍历: 建立一个index每一次index++, row = index/n, col = index%n
            - 存在多个移动方向:
                
#### DFS程序结构的实现艺术
- 入口函数
- 搜索函数
- 判断函数
- 打印函数

##### 组合类问题
- 无重复元素组合
    - DFS [0,1] 选择法
    - DFS 无序全排列 - 去掉全排列里面重复的值
- 有重复元素组合
    - DFS 无序全排列+同层去重 
    - DFS加哈希去重法
###### 非递归解法
- 两种方式实现全子集问题
    - BFS
    - Binary

##### 排列类问题
- 时间复杂度通常是指数级别
- NP(非多项式解法问题只能暴力搜索求解) - TSP问题
    - 什么是TSP问题中国邮政问题 - 一个图中经过所有的点一次且仅一次的最短路径边有权重(哈密尔顿问题) 
    - 什么是欧拉距离问题- 一个图经过所有的边 - 是P问题

###### 排列式搜索树
- 举例: 全排列同元素不同顺序是共存的

##### DFS进阶
- BFS和DFS优缺点
    - BFS: 
        - 优点: 可以更快找到最短路
        - 缺点: 耗费大量空间 - 随着深度指数级增长
    - DFS
        - 优点: 耗费额外空间少，只需线性空间 O(h)
        - 缺点: 不擅长找最短，容易陷入"深度陷阱", 如果问题中存在一个深坑陷阱 - DFS一定会扎进去LOL...
        
- DFS的缺陷
    - DFS会先往深处找
    - 是以先序遍历进行查找，如果目标在第二层最后一个节点，DFS还是要向下寻找然后回溯，相当浪费时间
- 问题：能不能把两者的优势结合起来 - IDDFS
    - 对DFS的深度加以限制
###### 迭代加深度搜索 IDDFS
- 基本思路
    1. 定义一个限制高度
    2. DFS到限制高度如果没有解接着提升高度
    3. 重复step 2直到找到解,这个解也就是最短路径(所有最短路径集合)



