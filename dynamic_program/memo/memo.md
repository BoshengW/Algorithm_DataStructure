### Memorization - 记忆化搜索

#### 什么是记忆化搜索 (动态规划的过渡算法)
- 函数返回前，记录函数的返回结果，在下一次以同样参数访问时直接返回缓存的结果
    - 记忆化搜索 == DFS + Memo
- Note: 记忆化搜索就是DP， Memo是DP的递归实现方式.

##### Time Complexity
-> DP时间复杂度 = O(状态总数*计算每一个状态时间消费)

#### 记忆化搜索函数的三个特点
- 函数有返回值
- 函数返回结果与输入参数相关，和其他全局状态无关
- 参数列表中传入Hash或者记录计算结果的数据结构

##### 入门例题 - Triangle(数字三角形) DP
- Note: 数字三角形和满二叉树很类似单节点数不同，
    - 复习 n 层满二叉树多少节点: 1 + 2 + 4 + ... + 2^n-1 = O(2^n) 
    - n 层数字三角形多少节点: 1 + 2 + ... + n = O(n^2)
- 解法分析：
    - O(2^n):
        - 暴力搜索 DFS - 会超时
        - 分治 DQ - 会超时
    -  分治优化:
        - 将重复运用的子问题保存起来，利用HashMap或者2D数组保存计算过的问题
    - DFS暴力搜索没办法进行记忆化，因为从上到下遍历没有重复运算，同样二叉树没办法没办法记忆化因为每一次都走一条新路

##### 入门例题 - Bash博弈游戏
- Note: 时间复杂度 O(n) 递归深度不能是O(n)会出现stackoverflow
    - 记忆化搜索通常采用递归 - 会有StackOverflow隐患
    - 动态规划就是天然的拓扑序

##### 记忆化搜索 缺陷
- 不适用O(N)时间复杂度的DP问题，因为记忆化搜索的递归Stack极限10^6
```
1 -> (x,y)
| \
2  3  -> (x,y+1) ; (x+1, y+1) 
|\  /\
4  5  6
```
